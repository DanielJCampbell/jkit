// This file is part of the Java Compiler Kit (JKit)
//
// The Java Compiler Kit is free software; you can 
// redistribute it and/or modify it under the terms of the 
// GNU General Public License as published by the Free Software 
// Foundation; either version 2 of the License, or (at your 
// option) any later version.
//
// The Java Compiler Kit is distributed in the hope
// that it will be useful, but WITHOUT ANY WARRANTY; without 
// even the implied warranty of MERCHANTABILITY or FITNESS FOR 
// A PARTICULAR PURPOSE.  See the GNU General Public License 
// for more details.
//
// You should have received a copy of the GNU General Public 
// License along with the Java Compiler Kit; if not, 
// write to the Free Software Foundation, Inc., 59 Temple Place, 
// Suite 330, Boston, MA  02111-1307  USA
//
// (C) David James Pearce, 2007. 

package jkit.io;

import java.io.*;
import java.util.*;
import java.lang.reflect.Modifier;

import jkit.core.*;
import jkit.util.*;
import jkit.util.graph.Graph;

public class JavaFileWriter implements ClassWriter {
	private PrintWriter output;

	public JavaFileWriter() {
		output = new PrintWriter(System.out);
	}
	
	public JavaFileWriter(Writer out) {
		output = new PrintWriter(out);
	}
	
	public JavaFileWriter(OutputStream out) {
		output = new PrintWriter(out);
	}
	
	public void writeClass(Clazz clazz) {		
		String pkg = clazz.type().pkg();
		output.println("/*********************************************************");
		output.println(" * Automatically generated by the Java compiler Kit (JKit)");
		output.println(" * on " + Calendar.getInstance().getTime());
		output.println(" *********************************************************/");
		
		if(!pkg.equals("")) {
			output.println("package " + pkg + ";");
		}		
		
		printImports(clazz);
		
		printClass(clazz,0);
		
		output.flush();
	}
	
	/**
     * The purpose of this method is to print out appropriate import statements.
     * To do this, we simply scan all types and collect their packages.
     * 
     * @param clazz
     */
	private void printImports(Clazz clazz) {
		HashSet<String> packages = new HashSet<String>();
		addPackages(clazz.superClass(),packages);
		
		for(Type i : clazz.interfaces()) {
			addPackages(i,packages);
		}
		
		for(Field f : clazz.fields()) {
			addPackages(f.type(),packages);
		}
		
		for(Method m : clazz.methods()) {
			addPackages(m.type(),packages);
			// will need to recurse method statements
			// here
		}
		
		for(String p : packages) {
			if(!p.equals("") && !p.equals("java.lang") && !p.equals(clazz.type().pkg())) {
				output.println("import " + p + ".*;");
			}
		}
	}
	
	/**
	 * The purpose of this method is to scan the type given and
	 * extract all packages that it, or types used by it, refer to.
	 * 
	 * @param t
	 * @param packages
	 */
	private void addPackages(Type t, Set<String> packages) {		
		if(t instanceof Type.Reference) {
			Type.Reference tr = (Type.Reference) t;  		
			packages.add(tr.pkg());
		} else if(t instanceof Type.Function) {
			Type.Function ft = (Type.Function) t;
			addPackages(ft.returnType(),packages);
			for(Type p : ft.parameterTypes()) {
				addPackages(p,packages);
			}
			for(Type ta : ft.typeArgs()) {
				addPackages(ta,packages);
			}
		}
	}
	
	private void printClass(Clazz clazz, int indent) {
		
		// ==============================
		// ======== DECLARATION =========
		// ==============================
		
		output.println("");
		indent(indent);
		printModifiers(clazz.modifiers());
		Type.Reference type = clazz.type();
		Type.Reference superClass = clazz.superClass();
		Pair<String,Type[]> classDecl = type.classes()[type.classes().length-1];
		if(clazz.isInterface()) {
			output.print("interface " + classDecl.first());
		} else {
			output.print("class " + classDecl.first());
		}
		Type[] typeParams = classDecl.second();
		if(typeParams.length > 0) {
			output.print("<");
			for(int i=0;i!=typeParams.length;++i) {
				if(i!=0) { output.print(","); }
				output.print(typeParams[i].toShortString());
			}
			output.print(">");
		}
		if(!jkit.util.bytecode.Types.descriptor(superClass,false).equals("Ljava/lang/Object;")) {
			output.print(" extends " + superClass.toShortString());
		}
		List<Type.Reference> interfaces = clazz.interfaces();
		if(interfaces.size() > 0) {
			if(clazz.isInterface()) {
				output.print(" extends ");
			} else {
				output.print(" implements ");
			}
			boolean firstTime=true;
			for(Type t : interfaces) {
				if(!firstTime) { output.print(", "); }
				firstTime=false;
				output.print(t.toShortString());
			}
		}
		output.println(" { ");
		
		// ==============================
		// ========== FIELDS ============
		// ==============================
								
		for(Field f : clazz.fields()) {
			printField(f,indent+1);
		}
			
		// ==============================
		// ========== METHODS ===========
		// ==============================
		
		if(clazz.fields().size() > 0) {
			output.println("");
		}		
		
		for(Method m : clazz.methods()) {			
			printMethod(m,clazz,indent+1);
		}
		
		// ==============================
		// ======= INNER CLASSES ========
		// ==============================		

		if(clazz.methods().size() > 0) {
			output.println("");
		}
		
		for(Pair<Type.Reference,Integer> ic : clazz.inners()) {
			try {
				printClass(ClassTable.findClass(ic.first()),indent+1);
			} catch(ClassNotFoundException e) {
				
			}
		}
			
		indent(indent);
		output.println("} ");			
	}
	
	private void printField(Field field, int indent) {
		indent(indent);
		printModifiers(field.modifiers());
		output.println(field.type().toShortString() + " " + field.name() + ";");
	}	
	
	private void printMethod(Method method, Clazz clazz, int indent) {
		indent(indent);		
		printModifiers(method.modifiers());
		Type.Function ft = method.type();
		
		if(ft.typeArgs().length > 0) {
			output.print("<");
			boolean firstTime=true;
			for(Type.Variable tv : ft.typeArgs()) {
				if(!firstTime) { output.print(","); }
				firstTime=false;
				output.print(tv.toShortString());
			}
			output.print("> ");
		}
		
		// === print return type, name and parameter types ===		
		if(!method.name().equals(clazz.name())) {
			output.print(ft.returnType().toShortString() + " ");
		}
		
		ArrayList<String> parameterNames = new ArrayList<String>();
		FlowGraph code = method.code();
		
		if(code != null) {
			for(FlowGraph.LocalVarDef v : code.localVariables()) {
				parameterNames.add(v.name());
			}
		} else {
			for(int i=0;i!=ft.parameterTypes().length;++i) {
				parameterNames.add("v" + Integer.toString(i));
			}
		}
		 
		output.print(method.name() + "(");
		boolean firstTime=true;
		Type[] parameterTypes = ft.parameterTypes();
		for(int i=0;i!=parameterTypes.length;++i) {
			if(!firstTime) { output.print(", "); }
			firstTime=false;
			output.print(parameterTypes[i].toShortString());
			output.print(" " + parameterNames.get(i));
		}		
		output.print(")");
		
		// === print throws clause ===
		List<Type.Reference> exceptions = method.exceptions();
		if(exceptions.size() > 0) {
			output.print(" throws ");
			firstTime=true;
			for(Type e : exceptions) {
				if(!firstTime) { output.print(", "); }
				firstTime=false;
				output.print(e.toShortString());
			}
		}
		
		if(method.isAbstract() | clazz.isInterface()) { output.println(";"); }
		else {
			assert code != null;
			output.println(" {");
			printCode(code,indent+1);					
			indent(indent);output.println("}");
		}
	}	
	
	private void printCode(FlowGraph code, int indent) {
				
		// === Variable Declarations ===
		
		for(FlowGraph.LocalVarDef v : code.localVariables()) {
			if(v.isParameter()) { continue; } // ignore parameters
			indent(indent+1);printModifiers(v.modifiers());
			output.println(v.type().toShortString() + " " + v.name() + ";");
		}
		
		// === Statements ===
		StringBuffer buf = printStatements(code, code.entry(), indent).third();
		output.print(buf.toString());
	
		// At this point is hard to proceed.
	}
	
	private ArrayList<FlowGraph.Point> seen = new ArrayList<FlowGraph.Point>();
	
	private boolean isBreakPoint(Graph<FlowGraph.Point, Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr>> cfg, FlowGraph.Point p) {
		for(FlowGraph.Point cp : seen) {
			Set<Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr>> from = cfg.from(cp);
			if(from.contains(p)) {
				return true;
			}
		}
		return false;
	}
	
	private Triple<FlowGraph.Point, FlowGraph.Point, StringBuffer> printStatements(Graph<FlowGraph.Point, Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr>> cfg,
															FlowGraph.Point entry, int indent) {
		FlowGraph.Point current = entry;
		StringBuffer buf = new StringBuffer();
		while(current != null) {
			Set<Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr>> from = cfg.from(current);
			Set<Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr>> to = cfg.to(current);
			if(from.size() == 1) {
				// Straight inline statement
				if(current.statement() != null) {
					indent(buf, indent + 1); buf.append(current.statement().toString() + ";\n");
				}
				
				FlowGraph.Point next = from.iterator().next().second();
				
				if(next.statement() == null) {
					if(cfg.from(next).size() == 2) {
						if(seen.contains(next)) {
							indent(buf, indent + 1); buf.append("continue;\n");
							return new Triple<FlowGraph.Point, FlowGraph.Point, StringBuffer>(current, next, buf);
						}
						else {
							if(isBreakPoint(cfg, next)) {
								indent(buf, indent + 1); buf.append("break;\n");
								return new Triple<FlowGraph.Point, FlowGraph.Point, StringBuffer>(current, next, buf);
							}
						}
					} else {
						return new Triple<FlowGraph.Point, FlowGraph.Point, StringBuffer>(current, next, buf);
					}
				}
				
				current = next;
				
			}
			else if(from.size() == 0) {
				indent(buf, indent + 1); buf.append(current.statement().toString() + ";\n");
				return new Triple<FlowGraph.Point, FlowGraph.Point, StringBuffer>(current, null, buf);
			}
			else if(from.size() == 2) {
				
				Iterator<Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr>> iter = from.iterator();
				Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr> first = iter.next();
				Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr> second = iter.next();
				
				seen.add(current);

				Triple<FlowGraph.Point, FlowGraph.Point, StringBuffer> fRet = printStatements(cfg, first.second(), indent + 1);
				Triple<FlowGraph.Point, FlowGraph.Point, StringBuffer> sRet = printStatements(cfg, second.second(), indent + 1);
				

				if(to.size() == 2) {
					//Iterator<Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr>> toIter = to.iterator();
					//Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr> toFirst = toIter.next();
					//Triple<FlowGraph.Point, FlowGraph.Point, FlowGraph.Expr> toSecond = toIter.next();
					if(first.second().statement() == null) {
						indent(buf, indent + 1);
						buf.append("while (" + second.third() + ") {\n" + sRet.third());
						indent(buf, indent + 1);
						buf.append("}\n");
						current = first.second();
					} else if(second.second().statement() == null) {
						indent(buf, indent + 1);
						buf.append("while (" + first.third() + ") {\n" + fRet.third());
						indent(buf, indent + 1);
						buf.append("}\n");
						current = second.second();
					}
				} else {
					if(first.second().statement() == null) {
						indent(buf, indent + 1);
						buf.append("if (" + second.third() + ") {\n" + sRet.third());
						indent(buf, indent + 1);
						buf.append("}\n");
						current = first.second();
					} else if(second.second().statement() == null) {
						indent(buf, indent + 1);
						buf.append("if (" + first.third() + ") {\n" + fRet.third());
						indent(buf, indent + 1);
						buf.append("}\n");
						current = second.second();
					} else {
						indent(buf, indent + 1);
						buf.append("if (" + first.third() + ") {\n" + fRet.third());
						indent(buf, indent + 1);
						buf.append("} else {\n" + sRet.third());
						indent(buf, indent + 1);
						buf.append("}\n");
						current = fRet.second();
					}
				}
				
			}
		}
		return null;
	}
	
	private void printModifiers(int modifiers) {
		if((modifiers & Modifier.STATIC)!=0) { output.print("static "); }
		if((modifiers & Modifier.ABSTRACT)!=0) { output.print("abstract "); }
		if((modifiers & Modifier.FINAL)!=0) { output.print("final "); }
		if((modifiers & Modifier.NATIVE)!=0) { output.print("native "); }
		if((modifiers & Modifier.PRIVATE)!=0) { output.print("private "); }
		if((modifiers & Modifier.PROTECTED)!=0) { output.print("protected "); }
		if((modifiers & Modifier.PUBLIC)!=0) { output.print("public "); }
		if((modifiers & Modifier.STRICT)!=0) { output.print("strict "); }
		if((modifiers & Modifier.SYNCHRONIZED)!=0) { output.print("synchronized "); }
		if((modifiers & Modifier.TRANSIENT)!=0) { output.print("transient "); }
		if((modifiers & Modifier.VOLATILE)!=0) { output.print("volatile "); }		
	}
	
	private void indent(int level) {
		for(int i=0;i!=level;++i) {
			output.print("\t");
		}
	}
	
	private void indent(StringBuffer buf, int level) {
		for(int i = 0; i != level; ++i) {
			buf.append("\t");
		}
	}
}
